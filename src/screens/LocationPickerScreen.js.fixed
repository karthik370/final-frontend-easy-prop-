import React, { useState, useEffect, useContext } from 'react';
import {
  StyleSheet,
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  ActivityIndicator,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  Dimensions
} from 'react-native';
import MapView, { Marker, PROVIDER_GOOGLE } from 'react-native-maps';
import * as Location from 'expo-location';
import { Ionicons } from '@expo/vector-icons';
import { AuthContext } from '../context/AuthContext';

const LocationPickerScreen = ({ route, navigation }) => {
  // Access callback from route params if it exists
  const { onSelectLocation, initialLocation } = route.params || {};
  
  // Auth context for user ID
  const { userToken } = useContext(AuthContext);
  
  // Map and location state
  const [region, setRegion] = useState({
    latitude: 20.5937,
    longitude: 78.9629,
    latitudeDelta: 25,
    longitudeDelta: 25,
  });
  
  // Marker position (for draggable marker)
  const [markerPosition, setMarkerPosition] = useState({
    latitude: 20.5937,
    longitude: 78.9629,
  });
  
  // Address details from reverse geocoding
  const [address, setAddress] = useState({
    address: '',
    city: '',
    state: '',
    country: 'India'
  });
  
  // Flag to prevent automatic jumping to user location when user manually selects a location
  const [locationSelectedByUser, setLocationSelectedByUser] = useState(false);
  
  // Selected location state (to pass back to parent screen)
  const [selectedLocation, setSelectedLocation] = useState(initialLocation || null);
  
  // UI states
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [locationSuggestions, setLocationSuggestions] = useState([]);
  
  // Get user's current location on component mount
  useEffect(() => {
    if (!locationSelectedByUser) {
      getMyLocation();
    }
  }, []);

  // Handle when map region starts to change (e.g. user starts panning)
  const onRegionChangeStart = () => {
    // We don't need to do anything here but might be useful for future features
  };

  // Handle when map region changes (e.g. user finishes panning)
  const onRegionChangeComplete = (newRegion) => {
    // Only update the region state
    setRegion(newRegion);
  };

  // Get user's current location and center map on it
  const getMyLocation = async () => {
    setIsLoading(true);
    
    try {
      // Request permission to access location
      const { status } = await Location.requestForegroundPermissionsAsync();
      
      if (status !== 'granted') {
        Alert.alert('Permission Denied', 'Please allow location access to use this feature.');
        setIsLoading(false);
        return;
      }
      
      // Try to get the current location with high accuracy first
      try {
        const position = await Location.getCurrentPositionAsync({
          accuracy: Location.Accuracy.High
        });
        
        const { latitude, longitude } = position.coords;
        
        console.log('Got user location (high accuracy):', latitude, longitude);
        
        // Update map region with user's location
        setRegion({
          latitude,
          longitude,
          latitudeDelta: 0.05,  // Zoom level - smaller is more zoomed in
          longitudeDelta: 0.05
        });
        
        // Update marker position
        setMarkerPosition({
          latitude,
          longitude
        });
        
        // Get the address at this location
        reverseGeocode(latitude, longitude);
      } catch (highAccuracyError) {
        console.warn('High accuracy location failed, trying balanced power accuracy:', highAccuracyError);
        
        // If high accuracy fails, try with balanced power/accuracy
        const position = await Location.getCurrentPositionAsync({
          accuracy: Location.Accuracy.Balanced
        });
        
        const { latitude, longitude } = position.coords;
        
        console.log('Got user location (balanced accuracy):', latitude, longitude);
        
        // Update map region with user's location
        setRegion({
          latitude,
          longitude,
          latitudeDelta: 0.05,
          longitudeDelta: 0.05
        });
        
        // Update marker position
        setMarkerPosition({
          latitude,
          longitude
        });
        
        // Get the address at this location
        reverseGeocode(latitude, longitude);
      }
    } catch (error) {
      console.error('Error getting current location:', error);
      Alert.alert('Location Error', 'Could not get your current location. Please ensure location services are enabled.');
    } finally {
      setIsLoading(false);
    }
  };

  // Get address from coordinates using reverse geocoding
  const reverseGeocode = async (latitude, longitude) => {
    try {
      const result = await Location.reverseGeocodeAsync({
        latitude,
        longitude
      });
      
      if (result && result.length > 0) {
        const location = result[0];
        console.log('Reverse geocode results:', location);
        
        // Build address from components
        const addressComponents = [];
        if (location.name) addressComponents.push(location.name);
        if (location.street) addressComponents.push(location.street);
        if (location.district) addressComponents.push(location.district);
        
        const addressText = addressComponents.join(', ');
        
        // Set address details
        setAddress({
          address: addressText,
          city: location.city || '',
          state: location.region || '',
          country: location.country || 'India'
        });
        
        // Also update the selected location for the confirmation button
        setSelectedLocation({
          coordinates: {
            type: 'Point',
            coordinates: [longitude, latitude] // GeoJSON format [longitude, latitude]
          },
          address: addressText,
          city: location.city || '',
          state: location.region || '',
          country: location.country || 'India',
          formattedAddress: [
            addressText,
            location.city,
            location.region,
            location.country
          ].filter(Boolean).join(', ')
        });
      }
    } catch (error) {
      console.error('Error reverse geocoding:', error);
    }
  };

  // Handle when user submits a search
  const handleSearchSubmit = async () => {
    if (!searchQuery.trim()) return;
    
    setIsLoading(true);
    
    try {
      // Try to geocode the search query to get coordinates
      const results = await Location.geocodeAsync(searchQuery);
      
      if (results && results.length > 0) {
        // Success - update the map to show the searched location
        const { latitude, longitude } = results[0];
        
        console.log('Geocoded search to:', latitude, longitude);
        
        // Mark as explicitly selected by user
        setLocationSelectedByUser(true);
        
        // Update map region with searched location
        setRegion({
          latitude,
          longitude,
          latitudeDelta: 0.05,
          longitudeDelta: 0.05
        });
        
        // Update marker position
        setMarkerPosition({
          latitude,
          longitude
        });
        
        // Get address for the new coordinates
        reverseGeocode(latitude, longitude);
      } else {
        // No geocoding results found
        console.log('No location found for:', searchQuery);
        Alert.alert('Location Not Found', 'Could not find the location you searched for. Please try a different search.');
      }
    } catch (error) {
      console.error('Error searching for location:', error);
      Alert.alert('Search Error', 'There was a problem finding this location. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };
  // Get location suggestions based on user input - Google Maps style
  const getLocationSuggestions = async (query) => {
    console.log('LOCATION SEARCH:', query, 'Length:', query?.length || 0);
    
    // Skip processing for very short queries
    if (!query || query.length < 3) { // Only show after at least 3 characters
      console.log('Search query too short, clearing suggestions');
      setLocationSuggestions([]);
      setShowSuggestions(false);
      return;
    }
    
    // Show suggestions immediately
    console.log('Search length good, showing suggestions box');
    setShowSuggestions(true);
    
    // Show loading state first
    setLocationSuggestions([
      { id: 'loading', name: 'Searching locations...', address: '', isLoading: true }
    ]);
    
    try {
      // Try to get better Google Maps-like suggestions through geocoding
      
      // First, try with the exact query to get precise matches
      const directResults = await Location.geocodeAsync(query);
      
      // We'll collect all valid suggestions here
      let allSuggestions = [];
      
      if (directResults && directResults.length > 0) {
        console.log(`Found ${directResults.length} direct matches`);
        
        // For each result, get detailed address information with reverse geocoding
        const enhancedSuggestions = await Promise.all(
          directResults.slice(0, 5).map(async (result, index) => {
            try {
              // Get detailed place information
              const reverseGeoResults = await Location.reverseGeocodeAsync({
                latitude: result.latitude,
                longitude: result.longitude
              });
              
              if (reverseGeoResults && reverseGeoResults.length > 0) {
                const place = reverseGeoResults[0];
                
                // Build a Google Maps-like display
                let primaryText = '';
                let secondaryText = '';
                
                // Primary text is usually a name, street, or POI
                if (place.name) {
                  primaryText = place.name;
                } else if (place.street) {
                  primaryText = place.street;
                } else {
                  primaryText = query;
                }
                
                // Secondary text has the area, city, region, country
                const addressParts = [];
                
                if (place.district && place.district !== primaryText) 
                  addressParts.push(place.district);
                
                if (place.city && !addressParts.includes(place.city)) 
                  addressParts.push(place.city);
                
                if (place.region && !addressParts.includes(place.region)) 
                  addressParts.push(place.region);
                
                if (place.country) 
                  addressParts.push(place.country);
                
                secondaryText = addressParts.join(', ');
                
                return {
                  id: `place-${index}`,
                  name: primaryText,
                  address: secondaryText || `${result.latitude.toFixed(6)}, ${result.longitude.toFixed(6)}`,
                  formattedAddress: secondaryText,
                  latitude: result.latitude,
                  longitude: result.longitude,
                  city: place.city || '',
                  state: place.region || '',
                  country: place.country || '',
                  placeId: `place-${index}-${Date.now()}`, // Create a unique ID
                  source: 'geocoding'
                };
              } else {
                // Fallback if reverse geocoding fails
                return {
                  id: `basic-${index}`,
                  name: query,
                  address: `${result.latitude.toFixed(6)}, ${result.longitude.toFixed(6)}`,
                  latitude: result.latitude,
                  longitude: result.longitude,
                  source: 'geocoding'
                };
              }
            } catch (error) {
              console.log('Error enhancing suggestion:', error);
              return null;
            }
          })
        );
        
        // Filter out any failed results
        allSuggestions = enhancedSuggestions.filter(s => s !== null);
      }
      
      // If we don't have enough suggestions, try with region qualifiers
      if (allSuggestions.length < 3) {
        // Try different regions to get more complete suggestions
        const regions = ['India', 'USA', 'UK', 'Europe', 'Australia'];
        
        for (const region of regions) {
          // Skip if we already have enough suggestions
          if (allSuggestions.length >= 5) break;
          
          const regionQuery = `${query}, ${region}`;
          console.log(`Trying with region: ${regionQuery}`);
          
          try {
            const regionResults = await Location.geocodeAsync(regionQuery);
            
            if (regionResults && regionResults.length > 0) {
              // For each result, get detailed address information with reverse geocoding
              const regionSuggestions = await Promise.all(
                regionResults.slice(0, 2).map(async (result, index) => {
                  try {
                    // Get detailed place information
                    const reverseGeoResults = await Location.reverseGeocodeAsync({
                      latitude: result.latitude,
                      longitude: result.longitude
                    });
                    
                    if (reverseGeoResults && reverseGeoResults.length > 0) {
                      const place = reverseGeoResults[0];
                      
                      // Build a Google Maps-like display with region context
                      let primaryText = '';
                      let secondaryText = '';
                      
                      // Primary text is usually a name, street, or POI
                      if (place.name) {
                        primaryText = place.name;
                      } else if (place.street) {
                        primaryText = place.street;
                      } else {
                        primaryText = query;
                      }
                      
                      // Secondary text has the area, city, region, country
                      const addressParts = [];
                      
                      if (place.district && place.district !== primaryText) 
                        addressParts.push(place.district);
                      
                      if (place.city && !addressParts.includes(place.city)) 
                        addressParts.push(place.city);
                      
                      if (place.region && !addressParts.includes(place.region)) 
                        addressParts.push(place.region);
                      
                      // Always include region context
                      if (place.country) 
                        addressParts.push(place.country);
                      else
                        addressParts.push(region);
                      
                      secondaryText = addressParts.join(', ');
                      
                      // For region searches, include region in ID to avoid duplicates
                      return {
                        id: `place-${region}-${index}`,
                        name: primaryText,
                        address: secondaryText || `${result.latitude.toFixed(6)}, ${result.longitude.toFixed(6)}`,
                        formattedAddress: secondaryText,
                        latitude: result.latitude,
                        longitude: result.longitude,
                        city: place.city || '',
                        state: place.region || '',
                        country: place.country || '',
                        source: 'geocoding',
                        region: region
                      };
                    }
                  } catch (error) {
                    console.log(`Error enhancing suggestion for ${region}:`, error);
                    return null;
                  }
                })
              );
              
              // Add these to our main suggestions
              allSuggestions.push(...regionSuggestions.filter(s => s !== null));
            }
          } catch (error) {
            console.log(`Error searching in region ${region}:`, error);
          }
        }
      }
      
      // Remove any duplicates by coordinates
      const uniqueSuggestions = [];
      const coordKeys = new Set();
      
      allSuggestions.forEach(suggestion => {
        if (!suggestion) return;
        
        const coordKey = `${parseFloat(suggestion.latitude).toFixed(4)},${parseFloat(suggestion.longitude).toFixed(4)}`;
        
        // If we haven't seen this coordinate yet
        if (!coordKeys.has(coordKey)) {
          coordKeys.add(coordKey);
          uniqueSuggestions.push(suggestion);
        }
      });
      
      console.log(`Final suggestion count: ${uniqueSuggestions.length}`);
      
      // Return results, or a message if none found
      if (uniqueSuggestions.length > 0) {
        setLocationSuggestions(uniqueSuggestions.slice(0, 7)); // Limit to 7 suggestions
      } else {
        setLocationSuggestions([{
          id: 'no-results',
          name: 'No locations found',
          address: 'Try a different search term',
          isError: true
        }]);
      }
    } catch (error) {
      console.error('Location search error:', error);
      setLocationSuggestions([{ 
        id: 'error', 
        name: 'Error searching for locations', 
        address: 'Please try again later',
        isError: true
      }]);
    }
  };
  
  // Handle when a user selects a location suggestion - FIXED VERSION for EXACT LOCATION
  const handleSuggestionSelect = (suggestion) => {
    console.log('Selected suggestion EXACT DATA:', JSON.stringify(suggestion));
    
    // Skip if this is a loading or error state
    if (suggestion.isLoading) return;
    
    // Hide suggestions immediately
    setShowSuggestions(false);
    setLocationSuggestions([]);
    
    // Set the search query to the selected suggestion name
    setSearchQuery(suggestion.name);
    
    // Mark that user has explicitly selected a location
    setLocationSelectedByUser(true);
    setIsLoading(true);
    
    try {
      // Check if the suggestion has valid coordinates
      if (suggestion.latitude && suggestion.longitude && 
          !isNaN(parseFloat(suggestion.latitude)) && !isNaN(parseFloat(suggestion.longitude))) {
        
        // Create exact coordinates with proper parsing to ensure numeric values
        const exactCoords = {
          latitude: parseFloat(suggestion.latitude),
          longitude: parseFloat(suggestion.longitude)
        };
        
        console.log('EXACT COORDINATES BEING USED:', JSON.stringify(exactCoords));
        
        // Force immediate region update with the exact coordinates
        setRegion({
          latitude: exactCoords.latitude,
          longitude: exactCoords.longitude,
          latitudeDelta: 0.01, // Zoom level - smaller means more zoomed in
          longitudeDelta: 0.01
        });
        
        // CRITICAL: Update marker position with exact same coordinates
        setMarkerPosition(exactCoords);
        
        // IMPORTANT: Update the selected location for the "Confirm Location" button
        setSelectedLocation({
          coordinates: {
            type: 'Point',
            coordinates: [exactCoords.longitude, exactCoords.latitude] // GeoJSON format: [long, lat]
          },
          address: suggestion.name || suggestion.address
        });
        
        // Set address directly using suggestion data
        setAddress({
          address: suggestion.name,
          city: suggestion.city || '',
          state: suggestion.state || '',
          country: suggestion.country || 'India'
        });
        
        // Get more detailed address information without changing coordinates
        reverseGeocode(exactCoords.latitude, exactCoords.longitude);
        
        setIsLoading(false);
      } else {
        // If we somehow got a suggestion without coordinates, geocode the address
        console.log('Need to geocode address:', suggestion.address);
        
        Location.geocodeAsync(suggestion.address || suggestion.name)
          .then(results => {
            if (results && results.length > 0) {
              const { latitude, longitude } = results[0];
              console.log('Successfully geocoded to:', latitude, longitude);
              
              // Update map region to center on the new location
              setRegion({
                latitude,
                longitude,
                latitudeDelta: 0.01,
                longitudeDelta: 0.01
              });
              
              // Update marker position
              setMarkerPosition({
                latitude,
                longitude
              });
              
              // Get full address details
              reverseGeocode(latitude, longitude);
            } else {
              console.log('No geocoding results found');
              setIsLoading(false);
              Alert.alert('Location Not Found', 'Could not find this location. Please try another search.');
            }
          })
          .catch(error => {
            console.error('Error geocoding location:', error);
            Alert.alert('Search Error', 'There was a problem finding this location. Please try again.');
            setIsLoading(false);
          });
      }
    } catch (error) {
      console.error('Error in handleSuggestionSelect:', error);
      Alert.alert('Error', 'An unexpected error occurred. Please try again.');
      setIsLoading(false);
    }
  };
  
  // Save selected location data and return to previous screen
  const saveLocation = () => {
    console.log('Saving location...');
    
    if (!selectedLocation) {
      console.log('No location selected');
      Alert.alert('No Location', 'Please select a location first');
      return;
    }
    
    console.log('Selected location:', selectedLocation);
    
    // If a callback was provided, call it with the selected location
    if (onSelectLocation) {
      onSelectLocation(selectedLocation);
    }
    
    // Go back to the previous screen
    navigation.goBack();
  };
  
  // Handle marker drag end
  const handleMarkerDragEnd = (e) => {
    const { latitude, longitude } = e.nativeEvent.coordinate;
    
    // Mark as explicitly selected by user through drag
    setLocationSelectedByUser(true);
    console.log(`Marker dragged to: ${latitude}, ${longitude}`);
    setMarkerPosition({
      latitude,
      longitude
    });
    
    // Also update the region to center on the marker
    setRegion({
      ...region,
      latitude,
      longitude
    });
    
    // Update address based on new coordinates
    reverseGeocode(latitude, longitude);
  };
  return (
    <View style={styles.container}>
      {/* Header with back button and title */}
      <View style={styles.header}>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Ionicons name="arrow-back" size={24} color="white" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Select Location</Text>
      </View>

      {/* Map View */}
      <MapView
        provider={PROVIDER_GOOGLE}
        style={styles.map}
        region={region}
        onRegionChangeStart={onRegionChangeStart}
        onRegionChangeComplete={onRegionChangeComplete}
        showsUserLocation={true}
        onPress={(e) => {
          // Set marker at tapped location
          const { latitude, longitude } = e.nativeEvent.coordinate;
          
          // Mark as explicitly selected by user through tap
          setLocationSelectedByUser(true);
          setMarkerPosition({ latitude, longitude });
          setRegion({
            ...region,
            latitude,
            longitude
          });
          
          // Update address based on new coordinates
          reverseGeocode(latitude, longitude);
        }}
      >
        <Marker
          coordinate={markerPosition}
          draggable
          onDragEnd={handleMarkerDragEnd}
        />
      </MapView>

      {/* Current position button */}
      <TouchableOpacity
        style={styles.currentPositionButton}
        onPress={getMyLocation}
      >
        <Ionicons name="locate" size={24} color="#0066cc" />
      </TouchableOpacity>
      
      {/* Loading indicator */}
      {isLoading && (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#0066cc" />
          <Text style={styles.loadingText}>Finding your location...</Text>
        </View>
      )}
      
      {/* Bottom panel with search and confirm */}
      <KeyboardAvoidingView
        style={styles.bottomPanel}
        behavior={Platform.OS === 'ios' ? 'padding' : null}
      >
        {/* Search bar */}
        <View style={styles.searchContainer}>
          <View style={styles.searchInputContainer}>
            <Ionicons name="search" size={20} color="#666" style={styles.searchIcon} />
            <TextInput
              style={styles.searchInput}
              placeholder="Search for a location..."
              value={searchQuery}
              onChangeText={(text) => {
                setSearchQuery(text);
                getLocationSuggestions(text);
              }}
              onSubmitEditing={handleSearchSubmit}
              returnKeyType="search"
            />
            {searchQuery ? (
              <TouchableOpacity
                style={styles.clearButton}
                onPress={() => {
                  setSearchQuery('');
                  setShowSuggestions(false);
                  setLocationSuggestions([]);
                }}
              >
                <Ionicons name="close-circle" size={20} color="#999" />
              </TouchableOpacity>
            ) : null}
          </View>
          <TouchableOpacity
            style={styles.searchButton}
            onPress={handleSearchSubmit}
          >
            <Ionicons name="search" size={20} color="#fff" />
          </TouchableOpacity>
        </View>
        
        {/* Location suggestions */}
        {showSuggestions && locationSuggestions.length > 0 && (
          <ScrollView style={styles.suggestionsContainer}>
            {locationSuggestions.map((suggestion) => (
              <TouchableOpacity
                key={suggestion.id}
                style={styles.suggestionItem}
                onPress={() => handleSuggestionSelect(suggestion)}
              >
                <View style={styles.suggestionContent}>
                  {suggestion.isLoading ? (
                    <ActivityIndicator size="small" color="#0066cc" style={styles.suggestionIcon} />
                  ) : (
                    <Ionicons name="location" size={18} color="#0066cc" style={styles.suggestionIcon} />
                  )}
                  <View style={styles.suggestionText}>
                    <Text style={styles.suggestionTitle} numberOfLines={1}>{suggestion.name}</Text>
                    <Text style={styles.suggestionAddress} numberOfLines={2}>{suggestion.address}</Text>
                  </View>
                </View>
              </TouchableOpacity>
            ))}
          </ScrollView>
        )}
        
        {/* Location information */}
        {selectedLocation && !showSuggestions && (
          <View style={styles.locationInfoContainer}>
            <Text style={styles.locationInfoTitle}>Selected Location</Text>
            <Text style={styles.locationInfoAddress}>{address.address}</Text>
            <Text style={styles.locationInfoDetails}>
              {[address.city, address.state, address.country].filter(Boolean).join(', ')}
            </Text>
          </View>
        )}
        
        {/* Confirm button */}
        <TouchableOpacity
          style={styles.confirmButton}
          onPress={saveLocation}
        >
          <Text style={styles.confirmButtonText}>Confirm Location</Text>
        </TouchableOpacity>
      </KeyboardAvoidingView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#0066cc',
    paddingTop: 40, // To account for status bar
    paddingBottom: 10,
    paddingHorizontal: 10,
    elevation: 4,
    zIndex: 10,
  },
  backButton: {
    padding: 8,
  },
  headerTitle: {
    color: 'white',
    fontSize: 18,
    fontWeight: '500',
    marginLeft: 10,
  },
  map: {
    flex: 1,
  },
  currentPositionButton: {
    position: 'absolute',
    right: 20,
    bottom: 250,
    backgroundColor: 'white',
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
    elevation: 3,
  },
  loadingContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.6)',
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#0066cc',
  },
  bottomPanel: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'white',
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  searchInputContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
    borderRadius: 8,
    paddingHorizontal: 10,
    paddingVertical: 8,
    marginRight: 8,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 40,
    fontSize: 16,
    color: '#333',
  },
  clearButton: {
    padding: 4,
  },
  searchButton: {
    backgroundColor: '#0066cc',
    borderRadius: 8,
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  suggestionsContainer: {
    maxHeight: 220,
    marginBottom: 12,
    backgroundColor: '#fff',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  suggestionItem: {
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  suggestionContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  suggestionIcon: {
    marginRight: 12,
  },
  suggestionText: {
    flex: 1,
  },
  suggestionTitle: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  suggestionAddress: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  locationInfoContainer: {
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    padding: 12,
    marginBottom: 12,
  },
  locationInfoTitle: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#666',
    marginBottom: 4,
  },
  locationInfoAddress: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
    marginBottom: 2,
  },
  locationInfoDetails: {
    fontSize: 14,
    color: '#666',
  },
  confirmButton: {
    backgroundColor: '#0066cc',
    borderRadius: 8,
    paddingVertical: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  confirmButtonText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: 'white',
  },
});

export default LocationPickerScreen;
