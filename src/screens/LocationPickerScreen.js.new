import React, { useState, useEffect, useContext } from 'react';
import {
  StyleSheet,
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
  Linking,
  ScrollView,
} from 'react-native';
import MapView, { Marker, PROVIDER_GOOGLE } from 'react-native-maps';
import { Ionicons } from '@expo/vector-icons';
import * as Location from 'expo-location';
import { LocationContext } from '../context/LocationContext';

const LocationPickerScreen = ({ route, navigation }) => {
  const { initialLocation } = route.params || {};
  const onSelectLocation = route.params?.onSelectLocation;
  const { location: contextLocation } = useContext(LocationContext);
  
  // Add a flag to prevent location jumping after user selection
  const [locationSelectedByUser, setLocationSelectedByUser] = useState(!!initialLocation);
  
  // Map region state
  const [region, setRegion] = useState({
    latitude: initialLocation?.coordinates?.coordinates[1] || 12.9716,
    longitude: initialLocation?.coordinates?.coordinates[0] || 77.5946,
    latitudeDelta: 0.0122,
    longitudeDelta: 0.0121,
  });
  
  // Marker position state
  const [markerPosition, setMarkerPosition] = useState({
    latitude: initialLocation?.coordinates?.coordinates[1] || 12.9716,
    longitude: initialLocation?.coordinates?.coordinates[0] || 77.5946,
  });
  
  // Address state for the selected location
  const [address, setAddress] = useState({
    address: initialLocation?.address || '',
    city: initialLocation?.city || '',
    state: initialLocation?.state || '',
    country: initialLocation?.country || 'India',
  });
  
  // Selected location state (to pass back to parent screen)
  const [selectedLocation, setSelectedLocation] = useState(initialLocation || null);
  
  // UI states
  const [isLoading, setIsLoading] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [locationSuggestions, setLocationSuggestions] = useState([]);
  
  // Get initial location based on device location
  useEffect(() => {
    // Skip if we already have an initial location
    if (initialLocation) return;
    
    // Only try to get device location if not already selected
    if (!locationSelectedByUser) {
      getMyLocation();
    }
  }, []);
  
  // Helpers for map interactions
  const onRegionChangeStart = () => {
    // Hide suggestions when map moves
    setShowSuggestions(false);
  };
  
  const onRegionChangeComplete = (newRegion) => {
    // Only update region state if the user hasn't selected a location yet
    if (!locationSelectedByUser) {
      setRegion(newRegion);
    }
  };
  
  // Get device location
  const getMyLocation = async () => {
    setIsLoading(true);
    try {
      // Check permissions
      const { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert(
          'Permission Required',
          'Location permission is needed to use your current location',
          [{ text: 'OK' }]
        );
        
        // Set default India location for testing when in emulator
        const defaultLatitude = 12.9716;
        const defaultLongitude = 77.5946;
        
        console.log('Using default India location for testing:', defaultLatitude, defaultLongitude);
        
        // Update marker position
        setMarkerPosition({
          latitude: defaultLatitude,
          longitude: defaultLongitude
        });
        
        // Update map region
        setRegion({
          latitude: defaultLatitude,
          longitude: defaultLongitude,
          latitudeDelta: 0.0122,
          longitudeDelta: 0.0121,
        });
        
        // Get address info from coordinates
        reverseGeocode(defaultLatitude, defaultLongitude);
        setIsLoading(false);
        return;
      }
      
      // Get device location if permission granted
      console.log('Getting current location...');
      const location = await Location.getCurrentPositionAsync({});
      const { latitude, longitude } = location.coords;
      
      // Update marker position
      setMarkerPosition({
        latitude,
        longitude
      });
      
      // Update map region
      setRegion({
        latitude,
        longitude,
        latitudeDelta: 0.0122,
        longitudeDelta: 0.0121,
      });
      
      // Get address info from coordinates
      reverseGeocode(latitude, longitude);
    } catch (error) {
      console.log('Error getting initial location, using default');
      
      // Set default location (Bangalore, India)
      const defaultLatitude = 12.9716; 
      const defaultLongitude = 77.5946;
      
      // Update marker position
      setMarkerPosition({
        latitude: defaultLatitude,
        longitude: defaultLongitude
      });
      
      // Update map region
      setRegion({
        latitude: defaultLatitude,
        longitude: defaultLongitude,
        latitudeDelta: 0.0122,
        longitudeDelta: 0.0121,
      });
      
      // Get address info from coordinates
      reverseGeocode(defaultLatitude, defaultLongitude);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Get address info from coordinates using reverse geocoding
  const reverseGeocode = async (latitude, longitude) => {
    try {
      const addresses = await Location.reverseGeocodeAsync({
        latitude,
        longitude
      });
      
      if (addresses && addresses.length > 0) {
        const address = addresses[0];
        
        // Set address info in state
        setAddress({
          address: address.name || address.street || '',
          city: address.city || address.subregion || '',
          state: address.region || '',
          country: address.country || 'India'
        });
        
        // Also update the selected location
        setSelectedLocation({
          coordinates: {
            type: 'Point',
            coordinates: [longitude, latitude] // GeoJSON format [longitude, latitude]
          },
          address: address.name || address.street || '',
          city: address.city || address.subregion || '',
          state: address.region || '',
          country: address.country || 'India'
        });
      }
    } catch (error) {
      console.error('Error reverse geocoding:', error);
    }
  };
  
  // Use Enter key to trigger search
  const handleSearchSubmit = () => {
    if (searchQuery.trim()) {
      console.log('Search submitted:', searchQuery);
      searchLocation();
    }
  };
  
  // Search for a location using geocoding
  const searchLocation = async () => {
    if (!searchQuery.trim()) return;
    
    console.log('SEARCH BUTTON PRESSED for:', searchQuery);
    setLocationSelectedByUser(true);
    setIsLoading(true);
    setShowSuggestions(false);
    
    try {
      // DIRECTLY use geocoding API to search ANY place in the world
      console.log('Geocoding worldwide search for:', searchQuery);
      const geocodeResult = await Location.geocodeAsync(searchQuery);
      
      if (geocodeResult && geocodeResult.length > 0) {
        const firstResult = geocodeResult[0];
        const { latitude, longitude } = firstResult;
        
        console.log('Found location at:', latitude, longitude);
        
        // Update map marker position
        setMarkerPosition({
          latitude,
          longitude
        });
        
        // Update the region to center on this location
        setRegion({
          latitude,
          longitude,
          latitudeDelta: 0.02, // Closer zoom for better view
          longitudeDelta: 0.02,
        });
        
        try {
          // Get the actual address using reverse geocoding
          const addresses = await Location.reverseGeocodeAsync({
            latitude,
            longitude
          });
          
          if (addresses && addresses.length > 0) {
            const address = addresses[0];
            
            // Format a complete address
            const formattedAddress = [
              address.name,
              address.street,
              address.district,
              address.city,
              address.region,
              address.country
            ].filter(Boolean).join(', ');
            
            console.log('Found address details:', formattedAddress);
            
            // Update address display with proper information
            setAddress({
              address: address.name || address.street || searchQuery,
              city: address.city || address.subregion || '',
              state: address.region || '',
              country: address.country || ''
            });
            
            console.log('Address set successfully');
          } else {
            // No detailed address found, use basic information
            setAddress({
              address: searchQuery,
              city: '',
              state: '',
              country: ''
            });
            console.log('No detailed address found, using search query');
          }
        } catch (addressError) {
          console.error('Error getting address details:', addressError);
          // Still set basic address info even if reverse geocoding fails
          setAddress({
            address: searchQuery,
            city: '',
            state: '',
            country: ''
          });
        }
      } else {
        // No geocoding results found
        console.log('No location found for:', searchQuery);
        Alert.alert('Location Not Found', 'Could not find the location you searched for. Please try a different search.');
      }
    } catch (error) {
      console.error('Error searching for location:', error);
      Alert.alert('Search Error', 'There was a problem finding this location. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };
  
  // Get location suggestions based on user input
  const getLocationSuggestions = async (query) => {
    // Add debug outputs
    console.log('LOCATION SEARCH:', query, 'Length:', query?.length || 0);
    
    // Skip processing for very short queries
    if (!query || query.length < 2) { // Reduced to 2 letters to be more responsive
      console.log('Search query too short, clearing suggestions');
      setLocationSuggestions([]);
      setShowSuggestions(false);
      return;
    }
    
    // Show suggestions immediately
    console.log('Search length good, showing suggestions box');
    setShowSuggestions(true);
    
    // Show loading state first
    setLocationSuggestions([
      { id: 'loading', name: 'Searching locations...', address: '', isLoading: true }
    ]);
    
    try {
      // Try geocoding the search query
      console.log('Searching worldwide locations for:', query);
      const results = await Location.geocodeAsync(query);
      
      if (results && results.length > 0) {
        // For each geocoding result, we need to get more details
        const geocodeSuggestions = results.slice(0, 8).map((result, index) => ({
          id: `geocoded-${index}`,
          name: `${query} (Location ${index+1})`,
          address: `${result.latitude.toFixed(6)}, ${result.longitude.toFixed(6)}`,
          latitude: result.latitude,
          longitude: result.longitude,
          source: 'geocoding'
        }));
        
        console.log(`Found ${geocodeSuggestions.length} geocoded locations:`, JSON.stringify(geocodeSuggestions));
        setLocationSuggestions(geocodeSuggestions);
      } else {
        // No geocoding results
        console.log('No geocoded results found');
        setLocationSuggestions([{ id: 'no-results', name: 'No locations found', address: 'Try a different search' }]);
      }
    } catch (error) {
      console.error('Location search error:', error);
      // Show error state
      setLocationSuggestions([{ id: 'error', name: 'Error searching', address: 'Try again' }]);
    }
  };
  
  // Handle when a user selects a location suggestion - FIXED VERSION for EXACT LOCATION
  const handleSuggestionSelect = (suggestion) => {
    console.log('Selected suggestion EXACT DATA:', JSON.stringify(suggestion));
    
    // Skip if this is a loading or error state
    if (suggestion.isLoading) return;
    
    // Hide suggestions immediately
    setShowSuggestions(false);
    setLocationSuggestions([]);
    
    // Set the search query to the selected suggestion name
    setSearchQuery(suggestion.name);
    
    // Mark that user has explicitly selected a location
    setLocationSelectedByUser(true);
    setIsLoading(true);
    
    try {
      // Check if the suggestion has valid coordinates
      if (suggestion.latitude && suggestion.longitude && 
          !isNaN(parseFloat(suggestion.latitude)) && !isNaN(parseFloat(suggestion.longitude))) {
        
        // Create exact coordinates with proper parsing to ensure numeric values
        const exactCoords = {
          latitude: parseFloat(suggestion.latitude),
          longitude: parseFloat(suggestion.longitude)
        };
        
        console.log('EXACT COORDINATES BEING USED:', JSON.stringify(exactCoords));
        
        // Force immediate region update with the exact coordinates
        setRegion({
          latitude: exactCoords.latitude,
          longitude: exactCoords.longitude,
          latitudeDelta: 0.01, // Zoom level - smaller means more zoomed in
          longitudeDelta: 0.01
        });
        
        // CRITICAL: Update marker position with exact same coordinates
        setMarkerPosition(exactCoords);
        
        // IMPORTANT: Update the selected location for the "Confirm Location" button
        setSelectedLocation({
          coordinates: {
            type: 'Point',
            coordinates: [exactCoords.longitude, exactCoords.latitude] // GeoJSON format: [long, lat]
          },
          address: suggestion.name || suggestion.address
        });
        
        // Set address directly using suggestion data
        setAddress({
          address: suggestion.name,
          city: suggestion.city || '',
          state: suggestion.state || '',
          country: suggestion.country || 'India'
        });
        
        // Get more detailed address information without changing coordinates
        reverseGeocode(exactCoords.latitude, exactCoords.longitude);
        
        setIsLoading(false);
        
        // Alert confirmation (can be removed in production)
        Alert.alert(
          'Location Selected',
          `Selected: ${suggestion.name}\nCoordinates: ${exactCoords.latitude.toFixed(6)}, ${exactCoords.longitude.toFixed(6)}`,
          [{ text: 'OK' }]
        );
      } else {
        // If we somehow got a suggestion without coordinates, geocode the address
        console.log('Need to geocode address:', suggestion.address);
        
        Location.geocodeAsync(suggestion.address || suggestion.name)
          .then(results => {
            if (results && results.length > 0) {
              const { latitude, longitude } = results[0];
              console.log('Successfully geocoded to:', latitude, longitude);
              
              // Update map region to center on the new location
              setRegion({
                latitude,
                longitude,
                latitudeDelta: 0.01,
                longitudeDelta: 0.01
              });
              
              // Update marker position
              setMarkerPosition({
                latitude,
                longitude
              });
              
              // Get full address details
              reverseGeocode(latitude, longitude);
            } else {
              console.log('No geocoding results found');
              setIsLoading(false);
              Alert.alert('Location Not Found', 'Could not find this location. Please try another search.');
            }
          })
          .catch(error => {
            console.error('Error geocoding location:', error);
            Alert.alert('Search Error', 'There was a problem finding this location. Please try again.');
            setIsLoading(false);
          });
      }
    } catch (error) {
      console.error('Error in handleSuggestionSelect:', error);
      Alert.alert('Error', 'An unexpected error occurred. Please try again.');
      setIsLoading(false);
    }
  };
  
  // Save selected location data and return to previous screen
  const saveLocation = () => {
    console.log('Saving location...');
    
    if (!selectedLocation) {
      console.log('No location selected');
      Alert.alert('No Location', 'Please select a location first');
      return;
    }
    
    console.log('Selected location:', selectedLocation);
    
    // If a callback was provided, call it with the selected location
    if (onSelectLocation) {
      onSelectLocation(selectedLocation);
    }
    
    // Go back to the previous screen
    navigation.goBack();
  };
  
  // Handle marker drag end
  const handleMarkerDragEnd = (e) => {
    const { latitude, longitude } = e.nativeEvent.coordinate;
    
    // Mark as explicitly selected by user through drag
    setLocationSelectedByUser(true);
    console.log(`Marker dragged to: ${latitude}, ${longitude}`);
    setMarkerPosition({
      latitude,
      longitude
    });
    
    // Also update the region to center on the marker
    setRegion({
      ...region,
      latitude,
      longitude
    });
    
    // Update address based on new coordinates
    reverseGeocode(latitude, longitude);
  };

  return (
    <View style={styles.container}>
      {/* Map View */}
      <MapView
        provider={PROVIDER_GOOGLE}
        style={styles.map}
        region={region}
        onRegionChangeStart={onRegionChangeStart}
        onRegionChangeComplete={onRegionChangeComplete}
        showsUserLocation={true}
        onPress={(e) => {
          // Set marker at tapped location
          const { latitude, longitude } = e.nativeEvent.coordinate;
          console.log(`Map tapped at: ${latitude}, ${longitude}`);
          
          // Mark as explicitly selected by user through map tap
          setLocationSelectedByUser(true);
          setMarkerPosition({ latitude, longitude });
          
          // Update region to center on the new marker position
          setRegion({
            ...region,
            latitude,
            longitude
          });
          
          // Update address based on new coordinates
          reverseGeocode(latitude, longitude);
        }}
      >
        <Marker
          coordinate={markerPosition}
          draggable
          onDragEnd={handleMarkerDragEnd}
        />
      </MapView>
      
      {/* Current position button */}
      <TouchableOpacity
        style={styles.currentPositionButton}
        onPress={getMyLocation}
      >
        <Ionicons name="locate" size={24} color="#0066cc" />
      </TouchableOpacity>
      
      {/* Loading indicator */}
      {isLoading && (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#0066cc" />
        </View>
      )}
      
      {/* Location info panel */}
      <KeyboardAvoidingView
        style={styles.bottomPanel}
        behavior={Platform.OS === 'ios' ? 'padding' : null}
      >
        <View style={styles.searchContainer}>
          <View style={styles.searchInputContainer}>
            <Ionicons name="search" size={20} color="#666" style={styles.searchIcon} />
            <TextInput
              style={styles.searchInput}
              placeholder="Search for a location..."
              value={searchQuery}
              onChangeText={(text) => {
                setSearchQuery(text);
                getLocationSuggestions(text);
              }}
              onSubmitEditing={handleSearchSubmit}
              returnKeyType="search"
            />
            {searchQuery ? (
              <TouchableOpacity
                style={styles.clearButton}
                onPress={() => {
                  setSearchQuery('');
                  setShowSuggestions(false);
                }}
              >
                <Ionicons name="close-circle" size={18} color="#999" />
              </TouchableOpacity>
            ) : null}
          </View>
          
          <TouchableOpacity
            style={styles.searchButton}
            onPress={searchLocation}
          >
            <Ionicons name="search" size={20} color="#fff" />
          </TouchableOpacity>
        </View>
        
        {/* Location suggestions */}
        {showSuggestions && locationSuggestions.length > 0 && (
          <ScrollView style={styles.suggestionsContainer}>
            {locationSuggestions.map((suggestion) => (
              <TouchableOpacity
                key={suggestion.id}
                style={styles.suggestionItem}
                onPress={() => handleSuggestionSelect(suggestion)}
              >
                <View style={styles.suggestionContent}>
                  {suggestion.isLoading ? (
                    <ActivityIndicator size="small" color="#0066cc" style={styles.suggestionIcon} />
                  ) : (
                    <Ionicons name="location" size={18} color="#0066cc" style={styles.suggestionIcon} />
                  )}
                  <View style={styles.suggestionText}>
                    <Text style={styles.suggestionTitle} numberOfLines={1}>{suggestion.name}</Text>
                    <Text style={styles.suggestionAddress} numberOfLines={1}>{suggestion.address}</Text>
                  </View>
                </View>
              </TouchableOpacity>
            ))}
          </ScrollView>
        )}
        
        {/* Selected location */}
        <View style={styles.locationInfoContainer}>
          <View style={styles.locationInfoHeader}>
            <Text style={styles.locationInfoTitle}>Selected Location</Text>
          </View>
          
          <View style={styles.locationDetails}>
            <Ionicons name="location" size={18} color="#0066cc" style={styles.locationIcon} />
            <View style={styles.locationTextContainer}>
              <Text style={styles.locationAddress} numberOfLines={2}>
                {address.address || 'Tap on the map to select a location'}
              </Text>
              <Text style={styles.locationArea} numberOfLines={1}>
                {[address.city, address.state, address.country].filter(Boolean).join(', ')}
              </Text>
            </View>
          </View>
          
          <Text style={styles.dragHint}>
            Drag the marker or use search to adjust the location
          </Text>
        </View>
        
        {/* Action buttons */}
        <View style={styles.buttonsContainer}>
          <TouchableOpacity
            style={styles.cancelButton}
            onPress={() => navigation.goBack()}
          >
            <Text style={styles.cancelButtonText}>Cancel</Text>
          </TouchableOpacity>
          
          <TouchableOpacity
            style={styles.confirmButton}
            onPress={saveLocation}
          >
            <Text style={styles.confirmButtonText}>Confirm Location</Text>
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  map: {
    flex: 1,
  },
  currentPositionButton: {
    position: 'absolute',
    right: 16,
    bottom: 300,
    backgroundColor: 'white',
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
    elevation: 3,
  },
  loadingContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.6)',
  },
  bottomPanel: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: 'white',
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    paddingHorizontal: 16,
    paddingTop: 16,
    paddingBottom: 24,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 4,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  searchInputContainer: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    paddingHorizontal: 12,
    marginRight: 8,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    height: 44,
    fontSize: 16,
  },
  clearButton: {
    padding: 6,
  },
  searchButton: {
    backgroundColor: '#0066cc',
    width: 44,
    height: 44,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  suggestionsContainer: {
    maxHeight: 220,
    marginBottom: 12,
    backgroundColor: '#fff',
    borderRadius: 8,
    borderWidth: 1,
    borderColor: '#e0e0e0',
  },
  suggestionItem: {
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  suggestionContent: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  suggestionIcon: {
    marginRight: 12,
  },
  suggestionText: {
    flex: 1,
  },
  suggestionTitle: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  suggestionAddress: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  locationInfoContainer: {
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    padding: 12,
    marginBottom: 16,
  },
  locationInfoHeader: {
    marginBottom: 8,
  },
  locationInfoTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  locationDetails: {
    flexDirection: 'row',
    alignItems: 'flex-start',
  },
  locationIcon: {
    marginRight: 12,
    marginTop: 2,
  },
  locationTextContainer: {
    flex: 1,
  },
  locationAddress: {
    fontSize: 16,
    color: '#333',
  },
  locationArea: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  dragHint: {
    marginTop: 10,
    fontSize: 12,
    color: '#666',
    fontStyle: 'italic',
  },
  buttonsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  cancelButton: {
    flex: 1,
    height: 48,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
    borderRadius: 8,
    marginRight: 8,
  },
  cancelButtonText: {
    fontSize: 16,
    color: '#666',
  },
  confirmButton: {
    flex: 2,
    height: 48,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#0066cc',
    borderRadius: 8,
  },
  confirmButtonText: {
    fontSize: 16,
    fontWeight: 'bold',
    color: 'white',
  },
});

export default LocationPickerScreen;
