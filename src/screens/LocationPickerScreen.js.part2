  // Get location suggestions based on user input - Google Maps style
  const getLocationSuggestions = async (query) => {
    console.log('LOCATION SEARCH:', query, 'Length:', query?.length || 0);
    
    // Skip processing for very short queries
    if (!query || query.length < 3) { // Only show after at least 3 characters
      console.log('Search query too short, clearing suggestions');
      setLocationSuggestions([]);
      setShowSuggestions(false);
      return;
    }
    
    // Show suggestions immediately
    console.log('Search length good, showing suggestions box');
    setShowSuggestions(true);
    
    // Show loading state first
    setLocationSuggestions([
      { id: 'loading', name: 'Searching locations...', address: '', isLoading: true }
    ]);
    
    try {
      // Try to get better Google Maps-like suggestions through geocoding
      
      // First, try with the exact query to get precise matches
      const directResults = await Location.geocodeAsync(query);
      
      // We'll collect all valid suggestions here
      let allSuggestions = [];
      
      if (directResults && directResults.length > 0) {
        console.log(`Found ${directResults.length} direct matches`);
        
        // For each result, get detailed address information with reverse geocoding
        const enhancedSuggestions = await Promise.all(
          directResults.slice(0, 5).map(async (result, index) => {
            try {
              // Get detailed place information
              const reverseGeoResults = await Location.reverseGeocodeAsync({
                latitude: result.latitude,
                longitude: result.longitude
              });
              
              if (reverseGeoResults && reverseGeoResults.length > 0) {
                const place = reverseGeoResults[0];
                
                // Build a Google Maps-like display
                let primaryText = '';
                let secondaryText = '';
                
                // Primary text is usually a name, street, or POI
                if (place.name) {
                  primaryText = place.name;
                } else if (place.street) {
                  primaryText = place.street;
                } else {
                  primaryText = query;
                }
                
                // Secondary text has the area, city, region, country
                const addressParts = [];
                
                if (place.district && place.district !== primaryText) 
                  addressParts.push(place.district);
                
                if (place.city && !addressParts.includes(place.city)) 
                  addressParts.push(place.city);
                
                if (place.region && !addressParts.includes(place.region)) 
                  addressParts.push(place.region);
                
                if (place.country) 
                  addressParts.push(place.country);
                
                secondaryText = addressParts.join(', ');
                
                return {
                  id: `place-${index}`,
                  name: primaryText,
                  address: secondaryText || `${result.latitude.toFixed(6)}, ${result.longitude.toFixed(6)}`,
                  formattedAddress: secondaryText,
                  latitude: result.latitude,
                  longitude: result.longitude,
                  city: place.city || '',
                  state: place.region || '',
                  country: place.country || '',
                  placeId: `place-${index}-${Date.now()}`, // Create a unique ID
                  source: 'geocoding'
                };
              } else {
                // Fallback if reverse geocoding fails
                return {
                  id: `basic-${index}`,
                  name: query,
                  address: `${result.latitude.toFixed(6)}, ${result.longitude.toFixed(6)}`,
                  latitude: result.latitude,
                  longitude: result.longitude,
                  source: 'geocoding'
                };
              }
            } catch (error) {
              console.log('Error enhancing suggestion:', error);
              return null;
            }
          })
        );
        
        // Filter out any failed results
        allSuggestions = enhancedSuggestions.filter(s => s !== null);
      }
      
      // If we don't have enough suggestions, try with region qualifiers
      if (allSuggestions.length < 3) {
        // Try different regions to get more complete suggestions
        const regions = ['India', 'USA', 'UK', 'Europe', 'Australia'];
        
        for (const region of regions) {
          // Skip if we already have enough suggestions
          if (allSuggestions.length >= 5) break;
          
          const regionQuery = `${query}, ${region}`;
          console.log(`Trying with region: ${regionQuery}`);
          
          try {
            const regionResults = await Location.geocodeAsync(regionQuery);
            
            if (regionResults && regionResults.length > 0) {
              // For each result, get detailed address information with reverse geocoding
              const regionSuggestions = await Promise.all(
                regionResults.slice(0, 2).map(async (result, index) => {
                  try {
                    // Get detailed place information
                    const reverseGeoResults = await Location.reverseGeocodeAsync({
                      latitude: result.latitude,
                      longitude: result.longitude
                    });
                    
                    if (reverseGeoResults && reverseGeoResults.length > 0) {
                      const place = reverseGeoResults[0];
                      
                      // Build a Google Maps-like display with region context
                      let primaryText = '';
                      let secondaryText = '';
                      
                      // Primary text is usually a name, street, or POI
                      if (place.name) {
                        primaryText = place.name;
                      } else if (place.street) {
                        primaryText = place.street;
                      } else {
                        primaryText = query;
                      }
                      
                      // Secondary text has the area, city, region, country
                      const addressParts = [];
                      
                      if (place.district && place.district !== primaryText) 
                        addressParts.push(place.district);
                      
                      if (place.city && !addressParts.includes(place.city)) 
                        addressParts.push(place.city);
                      
                      if (place.region && !addressParts.includes(place.region)) 
                        addressParts.push(place.region);
                      
                      // Always include region context
                      if (place.country) 
                        addressParts.push(place.country);
                      else
                        addressParts.push(region);
                      
                      secondaryText = addressParts.join(', ');
                      
                      // For region searches, include region in ID to avoid duplicates
                      return {
                        id: `place-${region}-${index}`,
                        name: primaryText,
                        address: secondaryText || `${result.latitude.toFixed(6)}, ${result.longitude.toFixed(6)}`,
                        formattedAddress: secondaryText,
                        latitude: result.latitude,
                        longitude: result.longitude,
                        city: place.city || '',
                        state: place.region || '',
                        country: place.country || '',
                        source: 'geocoding',
                        region: region
                      };
                    }
                  } catch (error) {
                    console.log(`Error enhancing suggestion for ${region}:`, error);
                    return null;
                  }
                })
              );
              
              // Add these to our main suggestions
              allSuggestions.push(...regionSuggestions.filter(s => s !== null));
            }
          } catch (error) {
            console.log(`Error searching in region ${region}:`, error);
          }
        }
      }
      
      // Remove any duplicates by coordinates
      const uniqueSuggestions = [];
      const coordKeys = new Set();
      
      allSuggestions.forEach(suggestion => {
        if (!suggestion) return;
        
        const coordKey = `${parseFloat(suggestion.latitude).toFixed(4)},${parseFloat(suggestion.longitude).toFixed(4)}`;
        
        // If we haven't seen this coordinate yet
        if (!coordKeys.has(coordKey)) {
          coordKeys.add(coordKey);
          uniqueSuggestions.push(suggestion);
        }
      });
      
      console.log(`Final suggestion count: ${uniqueSuggestions.length}`);
      
      // Return results, or a message if none found
      if (uniqueSuggestions.length > 0) {
        setLocationSuggestions(uniqueSuggestions.slice(0, 7)); // Limit to 7 suggestions
      } else {
        setLocationSuggestions([{
          id: 'no-results',
          name: 'No locations found',
          address: 'Try a different search term',
          isError: true
        }]);
      }
    } catch (error) {
      console.error('Location search error:', error);
      setLocationSuggestions([{ 
        id: 'error', 
        name: 'Error searching for locations', 
        address: 'Please try again later',
        isError: true
      }]);
    }
  };
  
  // Handle when a user selects a location suggestion - FIXED VERSION for EXACT LOCATION
  const handleSuggestionSelect = (suggestion) => {
    console.log('Selected suggestion EXACT DATA:', JSON.stringify(suggestion));
    
    // Skip if this is a loading or error state
    if (suggestion.isLoading) return;
    
    // Hide suggestions immediately
    setShowSuggestions(false);
    setLocationSuggestions([]);
    
    // Set the search query to the selected suggestion name
    setSearchQuery(suggestion.name);
    
    // Mark that user has explicitly selected a location
    setLocationSelectedByUser(true);
    setIsLoading(true);
    
    try {
      // Check if the suggestion has valid coordinates
      if (suggestion.latitude && suggestion.longitude && 
          !isNaN(parseFloat(suggestion.latitude)) && !isNaN(parseFloat(suggestion.longitude))) {
        
        // Create exact coordinates with proper parsing to ensure numeric values
        const exactCoords = {
          latitude: parseFloat(suggestion.latitude),
          longitude: parseFloat(suggestion.longitude)
        };
        
        console.log('EXACT COORDINATES BEING USED:', JSON.stringify(exactCoords));
        
        // Force immediate region update with the exact coordinates
        setRegion({
          latitude: exactCoords.latitude,
          longitude: exactCoords.longitude,
          latitudeDelta: 0.01, // Zoom level - smaller means more zoomed in
          longitudeDelta: 0.01
        });
        
        // CRITICAL: Update marker position with exact same coordinates
        setMarkerPosition(exactCoords);
        
        // IMPORTANT: Update the selected location for the "Confirm Location" button
        setSelectedLocation({
          coordinates: {
            type: 'Point',
            coordinates: [exactCoords.longitude, exactCoords.latitude] // GeoJSON format: [long, lat]
          },
          address: suggestion.name || suggestion.address
        });
        
        // Set address directly using suggestion data
        setAddress({
          address: suggestion.name,
          city: suggestion.city || '',
          state: suggestion.state || '',
          country: suggestion.country || 'India'
        });
        
        // Get more detailed address information without changing coordinates
        reverseGeocode(exactCoords.latitude, exactCoords.longitude);
        
        setIsLoading(false);
      } else {
        // If we somehow got a suggestion without coordinates, geocode the address
        console.log('Need to geocode address:', suggestion.address);
        
        Location.geocodeAsync(suggestion.address || suggestion.name)
          .then(results => {
            if (results && results.length > 0) {
              const { latitude, longitude } = results[0];
              console.log('Successfully geocoded to:', latitude, longitude);
              
              // Update map region to center on the new location
              setRegion({
                latitude,
                longitude,
                latitudeDelta: 0.01,
                longitudeDelta: 0.01
              });
              
              // Update marker position
              setMarkerPosition({
                latitude,
                longitude
              });
              
              // Get full address details
              reverseGeocode(latitude, longitude);
            } else {
              console.log('No geocoding results found');
              setIsLoading(false);
              Alert.alert('Location Not Found', 'Could not find this location. Please try another search.');
            }
          })
          .catch(error => {
            console.error('Error geocoding location:', error);
            Alert.alert('Search Error', 'There was a problem finding this location. Please try again.');
            setIsLoading(false);
          });
      }
    } catch (error) {
      console.error('Error in handleSuggestionSelect:', error);
      Alert.alert('Error', 'An unexpected error occurred. Please try again.');
      setIsLoading(false);
    }
  };
  
  // Save selected location data and return to previous screen
  const saveLocation = () => {
    console.log('Saving location...');
    
    if (!selectedLocation) {
      console.log('No location selected');
      Alert.alert('No Location', 'Please select a location first');
      return;
    }
    
    console.log('Selected location:', selectedLocation);
    
    // If a callback was provided, call it with the selected location
    if (onSelectLocation) {
      onSelectLocation(selectedLocation);
    }
    
    // Go back to the previous screen
    navigation.goBack();
  };
  
  // Handle marker drag end
  const handleMarkerDragEnd = (e) => {
    const { latitude, longitude } = e.nativeEvent.coordinate;
    
    // Mark as explicitly selected by user through drag
    setLocationSelectedByUser(true);
    console.log(`Marker dragged to: ${latitude}, ${longitude}`);
    setMarkerPosition({
      latitude,
      longitude
    });
    
    // Also update the region to center on the marker
    setRegion({
      ...region,
      latitude,
      longitude
    });
    
    // Update address based on new coordinates
    reverseGeocode(latitude, longitude);
  };
