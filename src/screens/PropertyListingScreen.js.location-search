// Add these functions to your PropertyListingScreen.js file

// Location search and suggestions implementation
const [searchQuery, setSearchQuery] = useState('');
const [showLocationSuggestions, setShowLocationSuggestions] = useState(false);
const [locationSuggestions, setLocationSuggestions] = useState([]);

// Get location suggestions based on text input (similar to LocationPickerScreen)
const getLocationSuggestions = async (query) => {
  if (!query || query.length < 2) {
    setLocationSuggestions([]);
    setShowLocationSuggestions(false);
    return;
  }
  
  setShowLocationSuggestions(true);
  
  // Show loading state first
  setLocationSuggestions([
    { id: 'loading', name: 'Searching locations...', address: '', isLoading: true }
  ]);
  
  try {
    // Use direct geocoding for faster results
    console.log('Searching locations for:', query);
    const results = await Location.geocodeAsync(query);
    
    if (results && results.length > 0) {
      // Process results to create suggestions
      const suggestions = await Promise.all(
        results.slice(0, 5).map(async (result, index) => {
          try {
            // Get address information for each result
            const reverseGeoResults = await Location.reverseGeocodeAsync({
              latitude: result.latitude,
              longitude: result.longitude
            });
            
            if (reverseGeoResults && reverseGeoResults.length > 0) {
              const place = reverseGeoResults[0];
              
              // Build a nice display name and address
              const primaryText = place.name || place.street || query;
              
              const addressParts = [];
              if (place.city) addressParts.push(place.city);
              if (place.region) addressParts.push(place.region);
              if (place.country) addressParts.push(place.country);
              const secondaryText = addressParts.join(', ');
              
              return {
                id: `place-${index}`,
                name: primaryText,
                address: secondaryText || `${result.latitude.toFixed(6)}, ${result.longitude.toFixed(6)}`,
                latitude: result.latitude,
                longitude: result.longitude,
                city: place.city || '',
                state: place.region || '',
                country: place.country || ''
              };
            }
          } catch (error) {
            console.log('Error getting place details:', error);
          }
          
          // Fallback if reverse geocoding fails
          return {
            id: `basic-${index}`,
            name: query,
            address: `${result.latitude.toFixed(6)}, ${result.longitude.toFixed(6)}`,
            latitude: result.latitude,
            longitude: result.longitude
          };
        })
      );
      
      // Filter out any failed results
      const validSuggestions = suggestions.filter(s => s !== null);
      setLocationSuggestions(validSuggestions);
    } else {
      // Try with a region qualifier if direct search fails
      try {
        const regionalResults = await Location.geocodeAsync(`${query}, India`);
        if (regionalResults && regionalResults.length > 0) {
          const regionalSuggestions = regionalResults.map((result, index) => ({
            id: `region-${index}`,
            name: query,
            address: 'India',
            latitude: result.latitude,
            longitude: result.longitude
          }));
          setLocationSuggestions(regionalSuggestions);
        } else {
          setLocationSuggestions([{ 
            id: 'no-results', 
            name: 'No locations found', 
            address: 'Try a different search term' 
          }]);
        }
      } catch (error) {
        console.error('Regional search error:', error);
        setLocationSuggestions([{ 
          id: 'error', 
          name: 'Error searching', 
          address: 'Try again' 
        }]);
      }
    }
  } catch (error) {
    console.error('Location search error:', error);
    setLocationSuggestions([{ 
      id: 'error', 
      name: 'Error searching', 
      address: 'Try again' 
    }]);
  }
};

// Handle selection of a location suggestion
const handleLocationSelect = (suggestion) => {
  // Skip if this is a loading or error state
  if (suggestion.isLoading) return;
  
  // Hide suggestions immediately
  setShowLocationSuggestions(false);
  
  console.log('Selected location:', suggestion);
  
  // Update the map location
  if (suggestion.latitude && suggestion.longitude) {
    // Update map region to center on the selected location
    setMapRegion({
      latitude: parseFloat(suggestion.latitude),
      longitude: parseFloat(suggestion.longitude),
      latitudeDelta: 0.05, // Wider view to show nearby properties
      longitudeDelta: 0.05
    });
    
    // Set the search query to the selected name
    setSearchQuery(suggestion.name);
    
    // Fetch properties near this location
    fetchPropertiesNearLocation(suggestion.latitude, suggestion.longitude);
  }
};

// Fetch properties near a specific location
const fetchPropertiesNearLocation = async (latitude, longitude) => {
  try {
    setIsLoading(true);
    
    // Calculate search radius (in km)
    const radius = 5; // 5km search radius
    
    // Call the API with location parameters
    const response = await axios.get(`${API_URL}/api/properties`, {
      params: {
        latitude,
        longitude,
        radius,
        category: selectedCategory
      }
    });
    
    if (response.data && response.data.properties) {
      setProperties(response.data.properties);
      
      // Check if we found any properties
      if (response.data.properties.length === 0) {
        Alert.alert(
          'No Properties Found',
          `No properties found near this location. Try expanding your search.`,
          [{ text: 'OK' }]
        );
      } else {
        // Show success message
        console.log(`Found ${response.data.properties.length} properties near the selected location`);
      }
    }
  } catch (error) {
    console.error('Error fetching properties by location:', error);
    Alert.alert('Error', 'Failed to fetch properties near this location');
  } finally {
    setIsLoading(false);
  }
};
