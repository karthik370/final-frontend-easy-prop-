import React, { useState, useEffect, useRef } from 'react';
import {
  StyleSheet,
  View,
  Text,
  FlatList,
  TouchableOpacity,
  Image,
  ActivityIndicator,
  TextInput,
  Platform,
  Dimensions,
  Alert,
  ScrollView,
} from 'react-native';
import MapView, { Marker, PROVIDER_GOOGLE } from 'react-native-maps';
import { Ionicons } from '@expo/vector-icons';
import axios from 'axios';
import { API_URL, ENDPOINTS } from '../config/api';
import PropertyCard from '../components/PropertyCard';
import * as Location from 'expo-location';

const { width, height } = Dimensions.get('window');

const PropertyListingScreen = ({ route, navigation }) => {
  // Get category from navigation params
  const { category } = route.params || { category: 'All' };
  console.log('PropertyListingScreen initialized with category:', category);
  
  // Main state variables
  const [properties, setProperties] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [userLocation, setUserLocation] = useState(null);
  const [selectedProperty, setSelectedProperty] = useState(null);
  const [mapRegion, setMapRegion] = useState({
    latitude: 12.9716,  // Default to Bangalore
    longitude: 77.5946,
    latitudeDelta: 0.0922,
    longitudeDelta: 0.0421,
  });
  const [viewMode, setViewMode] = useState('map'); // 'map' or 'list'
  
  // For location search and suggestions
  const [searchQuery, setSearchQuery] = useState('');
  const [locationSuggestions, setLocationSuggestions] = useState([]);
  const [showLocationSuggestions, setShowLocationSuggestions] = useState(false);
  
  // Load initial data when component mounts
  useEffect(() => {
    // Get user's current location
    getUserLocation();
    
    // Fetch properties for the selected category
    fetchPropertiesByCategory();
    
    console.log('Initial load, fetching properties for:', category);
  }, []);  
  
  // Simple location detection to avoid errors
  const getUserLocation = async () => {
    try {
      const { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
        console.log('Permission to access location was denied');
        return;
      }
      
      const location = await Location.getCurrentPositionAsync({});
      const { latitude, longitude } = location.coords;
      
      console.log(`User location: ${latitude}, ${longitude}`);
      setUserLocation({ latitude, longitude });
      
      // Update the map to show user's location
      setMapRegion({
        latitude,
        longitude,
        latitudeDelta: 0.05,
        longitudeDelta: 0.05,
      });
      
    } catch (error) {
      console.log('Error getting location:', error);
    }
  };

  // Toggle between map and list view
  const toggleViewMode = () => {
    setViewMode(viewMode === 'map' ? 'list' : 'map');
  };

  // Fetch properties from API based on category
  const fetchPropertiesByCategory = async (searchLocation = null) => {
    setIsLoading(true);
    
    try {
      // We'll use the endpoints from your API config file
      let url = `${API_URL}${ENDPOINTS.PROPERTIES}`;
      
      console.log('Base API URL:', url);
      console.log('Fetching properties for category:', category);
      
      // Create a params object to build the query
      const params = new URLSearchParams();
      
      // Add category parameter if needed
      if (category && category !== 'All') {
        // Special handling for PG/Hostel category - we'll use property type filtering
        if (category === 'PG' || category === 'Hostel' || category === 'PG/Hostel') {
          // For PG/Hostel category, don't filter by category at all
          console.log('Fetching PG and Hostel properties with any category');
        } else if (category === 'Buy') {
          // Buy properties should use the Sell category in database
          params.append('category', 'Sell');
          console.log('Added category=Sell filter for Buy properties');
        } else {
          // For other categories (Rent), use the category directly
          params.append('category', category);
          console.log(`Added category=${category} filter`);
        }
      }
      
      // Add search query if available
      if (searchQuery) {
        params.append('search', searchQuery);
        console.log(`Added search=${searchQuery} filter`);
      }
      
      // Add location search if passed - normally this would query the backend
      // but here we'll just store it in the component for client-side filtering
      if (searchLocation) {
        console.log(`Searching near location: ${JSON.stringify(searchLocation)}`);
        // In a real app, you would add lat/long params to filter by location on the server
      }
      
      // Append the query params to the URL
      const queryString = params.toString();
      if (queryString) {
        url = `${url}?${queryString}`;
      }
      
      console.log('Fetching properties from:', url);
      
      const response = await axios.get(url);
      console.log('API response received');
      
      if (response.data && response.data.properties && Array.isArray(response.data.properties)) {
        // The properties are in the 'properties' key of the response
        let properties = response.data.properties;
        console.log(`Found ${properties.length} total properties from database`);
        
        // Client-side filtering for PG/Hostel properties
        if (category === 'PG' || category === 'Hostel' || category === 'PG/Hostel') {
          // Filter to only show properties with PG or Hostel property type
          const filteredProperties = properties.filter(property => 
            property.propertyType === 'PG' || property.propertyType === 'Hostel'
          );
          properties = filteredProperties;
          console.log(`Filtered to ${properties.length} PG/Hostel properties`);
        }
        
        if (properties.length > 0) {
          // Log first property to see its structure
          console.log('Sample property data:', JSON.stringify(properties[0]));
          
          // Set the properties from the nested array
          setProperties(properties);
          
          // Update the map to show these properties, but only if no specific search location
          // If searchLocation is provided, we'll keep the map centered there
          if (!searchLocation) {
            fitMapToProperties(properties);
          }
        } else {
          // No properties for this category
          console.log('No properties found for this category/type in database');
          setProperties([]);
        }
      } else {
        console.log('Unexpected API response format:', response.data);
        setProperties([]);
      }
    } catch (error) {
      console.error('Error fetching properties:', error);
      setProperties([]);
    } finally {
      setIsLoading(false);
    }
  };

  // Function to fit the map to show all properties
  const fitMapToProperties = (propertiesToFit) => {
    if (!propertiesToFit || propertiesToFit.length === 0) return;
    
    try {
      // Extract coordinates from properties
      let validLocations = propertiesToFit
        .filter(prop => prop.location && prop.location.coordinates && prop.location.coordinates.coordinates)
        .map(prop => {
          const coords = prop.location.coordinates.coordinates;
          console.log(`Property ${prop.title} has coordinates: ${coords}`);
          return {
            latitude: coords[1],
            longitude: coords[0],
          };
        });
      
      console.log(`Found ${validLocations.length} properties with valid coordinates`);
      
      if (validLocations.length === 0) return;
      
      if (validLocations.length === 1) {
        // If there's only one location, center on it
        setMapRegion({
          latitude: validLocations[0].latitude,
          longitude: validLocations[0].longitude,
          latitudeDelta: 0.02,
          longitudeDelta: 0.02,
        });
        return;
      }
      
      // Calculate the bounding box for all locations
      let minLat = Math.min(...validLocations.map(loc => loc.latitude));
      let maxLat = Math.max(...validLocations.map(loc => loc.latitude));
      let minLng = Math.min(...validLocations.map(loc => loc.longitude));
      let maxLng = Math.max(...validLocations.map(loc => loc.longitude));
      
      // Add a small padding
      const latPadding = (maxLat - minLat) * 0.2;
      const lngPadding = (maxLng - minLng) * 0.2;
      
      minLat -= latPadding;
      maxLat += latPadding;
      minLng -= lngPadding;
      maxLng += lngPadding;
      
      // Calculate center and deltas
      const centerLat = (minLat + maxLat) / 2;
      const centerLng = (minLng + maxLng) / 2;
      const latDelta = maxLat - minLat;
      const lngDelta = maxLng - minLng;
      
      setMapRegion({
        latitude: centerLat,
        longitude: centerLng,
        latitudeDelta: latDelta,
        longitudeDelta: lngDelta,
      });
      
      console.log(`Map region updated to center: ${centerLat}, ${centerLng}`);
    } catch (error) {
      console.error('Error fitting map to properties:', error);
    }
  };
  
  // For map markers
  const renderPropertyMarkers = () => {
    if (!properties || properties.length === 0) return null;
    
    // Filter properties to only include those with valid coordinates
    const propertiesWithCoords = properties.filter(property => 
      property.location && 
      property.location.coordinates && 
      property.location.coordinates.coordinates
    );
    
    console.log(`Rendering ${propertiesWithCoords.length} markers on map`);
    
    return propertiesWithCoords.map(property => {
      // Extract coordinates from the nested structure
      const coordinates = property.location.coordinates.coordinates;
      
      // GeoJSON stores coordinates as [longitude, latitude]
      const latitude = coordinates[1];
      const longitude = coordinates[0];
      
      return (
        <Marker
          key={property._id}
          coordinate={{ latitude, longitude }}
          title={property.title}
          description={`${property.price} - ${property.propertyType}`}
          onPress={() => handlePropertyPress(property)}
        >
          <View style={styles.markerContainer}>
            <View style={[
              styles.marker, 
              selectedProperty && selectedProperty._id === property._id 
                ? styles.selectedMarker 
                : null
            ]}>
              <Text style={styles.markerPrice}>
                â‚¹{property.price >= 100000 ? 
                  `${Math.round(property.price / 100000)}L` : 
                  property.price.toLocaleString()}
              </Text>
            </View>
            <View style={styles.markerArrow} />
          </View>
        </Marker>
      );
    });
  };
  
  // Simple property marker handler with error prevention
  const handlePropertyPress = (property) => {
    if (!property) return;
    console.log('Property selected:', property.title);
    setSelectedProperty(property);
  };

  // Get location suggestions based on user input - Google Maps style
  const getLocationSuggestions = async (query) => {
    console.log('LOCATION SEARCH:', query, 'Length:', query?.length || 0);
    
    // Skip processing for very short queries
    if (!query || query.length < 3) {
      console.log('Search query too short, clearing suggestions');
      setLocationSuggestions([]);
      setShowLocationSuggestions(false);
      return;
    }
    
    // Show suggestions immediately
    console.log('Search length good, showing suggestions box');
    setShowLocationSuggestions(true);
    
    // Show loading state first
    setLocationSuggestions([
      { id: 'loading', name: 'Searching locations...', address: '', isLoading: true }
    ]);
    
    try {
      // Try geocoding with the query
      const results = await Location.geocodeAsync(query);
      
      if (results && results.length > 0) {
        const suggestions = await Promise.all(
          results.slice(0, 5).map(async (result, index) => {
            try {
              // Get detailed place information
              const reverseGeoResults = await Location.reverseGeocodeAsync({
                latitude: result.latitude,
                longitude: result.longitude
              });
              
              if (reverseGeoResults && reverseGeoResults.length > 0) {
                const place = reverseGeoResults[0];
                
                // Build a Google Maps-like display
                let primaryText = place.name || place.street || query;
                
                // Secondary text has the area, city, region, country
                const addressParts = [];
                if (place.district) addressParts.push(place.district);
                if (place.city) addressParts.push(place.city);
                if (place.region) addressParts.push(place.region);
                if (place.country) addressParts.push(place.country);
                
                const secondaryText = addressParts.join(', ');
                
                return {
                  id: `geocoded-${index}`,
                  name: primaryText,
                  address: secondaryText || 'Unknown location',
                  latitude: result.latitude,
                  longitude: result.longitude,
                  source: 'geocoding'
                };
              }
            } catch (error) {
              console.error('Error getting reverse geocoding details:', error);
            }
            
            // Fallback if reverse geocoding fails
            return {
              id: `geocoded-simple-${index}`,
              name: query,
              address: `${result.latitude.toFixed(6)}, ${result.longitude.toFixed(6)}`,
              latitude: result.latitude,
              longitude: result.longitude,
              source: 'geocoding'
            };
          })
        );
        
        setLocationSuggestions(suggestions.filter(Boolean));
      } else {
        setLocationSuggestions([{ id: 'no-results', name: 'No locations found', address: 'Try a different search' }]);
      }
    } catch (error) {
      console.error('Error searching for location:', error);
      setLocationSuggestions([{ id: 'error', name: 'Error searching', address: 'Please try again' }]);
    }
  };

  // Handle when a user selects a location suggestion
  const handleSuggestionSelect = (suggestion) => {
    console.log('Selected suggestion:', JSON.stringify(suggestion));
    
    // Skip if this is a loading or error state
    if (suggestion.isLoading) return;
    
    // Hide suggestions immediately
    setShowLocationSuggestions(false);
    setLocationSuggestions([]);
    
    // Set the search query to the selected suggestion name
    setSearchQuery(suggestion.name);
    
    try {
      // Ensure we have valid coordinates
      if (suggestion.latitude && suggestion.longitude && 
          !isNaN(parseFloat(suggestion.latitude)) && !isNaN(parseFloat(suggestion.longitude))) {
        
        // Create clean coordinates object
        const coords = {
          latitude: parseFloat(suggestion.latitude),
          longitude: parseFloat(suggestion.longitude)
        };
        
        console.log('Moving map to coordinates:', coords);
        
        // Update map region
        setMapRegion({
          latitude: coords.latitude,
          longitude: coords.longitude,
          latitudeDelta: 0.015,
          longitudeDelta: 0.015,
        });
        
        // Fetch properties near this location
        fetchPropertiesByCategory(coords);
        
        // Clear any selected property
        if (selectedProperty) {
          setSelectedProperty(null);
        }
      } else {
        console.warn('Missing coordinates in suggestion:', suggestion);
        Alert.alert('Location Error', 'Please try another location');
      }
    } catch (error) {
      console.error('Error handling location selection:', error);
      Alert.alert('Error', 'An error occurred selecting this location');
    }
  };
  
  // Enhanced search function to prevent jumping to user location
  const handleSearch = async () => {
    if (!searchQuery.trim()) return;
    
    console.log('Searching for:', searchQuery);
    setIsLoading(true);
    
    try {
      // Attempt to geocode the search query
      const geocodeResult = await Location.geocodeAsync(searchQuery);
      
      if (geocodeResult && geocodeResult.length > 0) {
        console.log('Found location for search query');
        const { latitude, longitude } = geocodeResult[0];
        
        // Update the map region to center on the search location
        setMapRegion({
          latitude,
          longitude,
          latitudeDelta: 0.015,
          longitudeDelta: 0.015,
        });
        
        // Pass this location to the fetchProperties function
        fetchPropertiesByCategory({ latitude, longitude });
      } else {
        console.log('No location found for search query, just searching by text');
        // If no location was found, just search by text
        fetchPropertiesByCategory();
      }
    } catch (error) {
      console.error('Error geocoding search query:', error);
      // Just search by text if geocoding fails
      fetchPropertiesByCategory();
    }
  };

  return (
    <View style={styles.container}>
      {isLoading && (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#0066cc" />
          <Text style={styles.loadingText}>Finding properties...</Text>
        </View>
      )}
      
      {/* Header with search */}
      <View style={styles.header}>
        <View style={styles.searchContainer}>
          <TextInput
            style={styles.searchInput}
            placeholder="Search for location..."
            value={searchQuery}
            onChangeText={(text) => {
              setSearchQuery(text);
              // Instant suggestions after 3 characters
              if (text.length >= 3) {
                getLocationSuggestions(text);
              } else {
                setLocationSuggestions([]);
                setShowLocationSuggestions(false);
              }
            }}
            onSubmitEditing={() => handleSearch()}
          />
          {searchQuery ? (
            <TouchableOpacity
              style={styles.clearButton}
              onPress={() => {
                setSearchQuery('');
                setLocationSuggestions([]);
                setShowLocationSuggestions(false);
              }}
            >
              <Ionicons name="close-circle" size={22} color="#999" />
            </TouchableOpacity>
          ) : null}
          <TouchableOpacity
            style={styles.searchButton}
            onPress={() => handleSearch()}
          >
            <Ionicons name="search" size={24} color="#fff" />
          </TouchableOpacity>
        </View>
        
        {/* Location Suggestions Panel */}
        {showLocationSuggestions && locationSuggestions.length > 0 && (
          <View style={styles.suggestionsContainer}>
            <ScrollView keyboardShouldPersistTaps="handled">
              {locationSuggestions.map((suggestion) => (
                <TouchableOpacity
                  key={suggestion.id}
                  style={styles.suggestionItem}
                  onPress={() => handleSuggestionSelect(suggestion)}
                >
                  <View style={styles.locationDetails}>
                    <View style={styles.locationIcon}>
                      <Ionicons name="location" size={24} color="#0066cc" />
                    </View>
                    <View style={styles.locationTextContainer}>
                      <Text style={styles.locationName}>{suggestion.name}</Text>
                      <Text style={styles.locationAddress}>{suggestion.address}</Text>
                    </View>
                  </View>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </View>
        )}
      </View>
      
      {/* Content - Map and List Views */}
      <View style={styles.content}>
        {viewMode === 'map' ? (
          <View style={styles.mapSection}>
            <MapView
              provider={PROVIDER_GOOGLE}
              style={styles.map}
              region={mapRegion}
              showsUserLocation={true}
              showsMyLocationButton={true}
            >
              {renderPropertyMarkers()}
            </MapView>
            
            {selectedProperty && (
              <View style={styles.propertyInfoBox}>
                <PropertyCard 
                  property={selectedProperty} 
                  onPress={() => navigation.navigate('PropertyDetails', { property: selectedProperty })} 
                />
              </View>
            )}
            
            {/* Toggle view mode button */}
            <TouchableOpacity style={styles.viewModeButton} onPress={toggleViewMode}>
              <Ionicons name="list" size={24} color="#0066cc" />
              <Text style={styles.viewModeText}>List View</Text>
            </TouchableOpacity>
            
            {/* Current position button */}
            <TouchableOpacity
              style={styles.myLocationButton}
              onPress={getUserLocation}
            >
              <Ionicons name="locate" size={24} color="#0066cc" />
            </TouchableOpacity>
          </View>
        ) : (
          <View style={styles.listSection}>
            <View style={styles.listHeader}>
              <Text style={styles.listHeaderText}>Properties in {category}</Text>
              <Text style={styles.listCount}>{properties.length} found</Text>
              
              {/* Toggle view mode button in list view */}
              <TouchableOpacity style={styles.viewModeButtonInList} onPress={toggleViewMode}>
                <Ionicons name="map" size={20} color="#0066cc" />
                <Text style={styles.viewModeTextInList}>Map</Text>
              </TouchableOpacity>
            </View>
            
            {properties.length > 0 ? (
              <FlatList
                data={properties}
                keyExtractor={item => item._id || Math.random().toString()}
                renderItem={({ item }) => (
                  <PropertyCard 
                    property={item} 
                    onPress={() => {
                      handlePropertyPress(item);
                      navigation.navigate('PropertyDetails', { property: item });
                    }}
                  />
                )}
                contentContainerStyle={styles.listContent}
              />
            ) : (
              <View style={styles.noResults}>
                <Text style={styles.noResultsText}>No properties found</Text>
                <Text style={styles.noResultsSubtext}>Try changing your search criteria</Text>
              </View>
            )}
          </View>
        )}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8f8f8',
  },
  header: {
    backgroundColor: '#fff',
    padding: 10,
    paddingTop: Platform.OS === 'ios' ? 50 : 10,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
    zIndex: 10,
    elevation: 10, // For Android shadow
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
    borderRadius: 10,
    paddingHorizontal: 10,
    marginBottom: 5,
  },
  searchInput: {
    flex: 1,
    height: 44,
    fontSize: 16,
    color: '#333',
  },
  clearButton: {
    padding: 8,
  },
  searchButton: {
    marginLeft: 8,
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#0066cc',
    justifyContent: 'center',
    alignItems: 'center',
  },
  suggestionsContainer: {
    position: 'absolute',
    top: 65, // Position right below search bar
    left: 10,
    right: 10,
    maxHeight: 270,
    backgroundColor: '#fff',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#e8e8e8',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 20, // High elevation to appear above map
    zIndex: 20, // High z-index to appear above map
  },
  suggestionItem: {
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  locationDetails: {
    flexDirection: 'row',
    alignItems: 'flex-start',
  },
  locationIcon: {
    marginRight: 12,
    marginTop: 2,
  },
  locationTextContainer: {
    flex: 1,
  },
  locationName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  locationAddress: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
  content: {
    flex: 1,
  },
  mapSection: {
    flex: 1,
    position: 'relative',
  },
  map: {
    ...StyleSheet.absoluteFillObject,
  },
  propertyInfoBox: {
    position: 'absolute',
    bottom: 10,
    left: 10,
    right: 10,
    backgroundColor: 'white',
    borderRadius: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
    overflow: 'hidden',
  },
  viewModeButton: {
    position: 'absolute',
    top: 10,
    right: 10,
    backgroundColor: 'white',
    padding: 10,
    borderRadius: 10,
    flexDirection: 'row',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
    elevation: 5,
  },
  viewModeText: {
    marginLeft: 5,
    color: '#0066cc',
    fontWeight: '600',
  },
  myLocationButton: {
    position: 'absolute',
    bottom: 80,
    right: 10,
    backgroundColor: 'white',
    width: 44,
    height: 44,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
    elevation: 5,
  },
  listSection: {
    flex: 1,
  },
  listHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
    backgroundColor: '#f0f0f0',
  },
  listHeaderText: {
    fontSize: 18,
    fontWeight: 'bold',
    flex: 1,
  },
  listCount: {
    fontSize: 14,
    color: '#666',
    marginRight: 10,
  },
  viewModeButtonInList: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#0066cc20',
    paddingVertical: 5,
    paddingHorizontal: 10,
    borderRadius: 15,
  },
  viewModeTextInList: {
    marginLeft: 5,
    color: '#0066cc',
    fontSize: 12,
    fontWeight: '600',
  },
  listContent: {
    paddingHorizontal: 10,
    paddingTop: 5,
    paddingBottom: 20,
  },
  noResults: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  noResultsText: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  noResultsSubtext: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
  },
  loadingContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(255,255,255,0.8)',
    zIndex: 999,
    elevation: 999,
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#0066cc',
  },
  markerContainer: {
    alignItems: 'center',
  },
  marker: {
    backgroundColor: '#0066cc',
    padding: 5,
    paddingHorizontal: 8,
    borderRadius: 4,
  },
  selectedMarker: {
    backgroundColor: '#ff6600',
    padding: 7,
    paddingHorizontal: 10,
  },
  markerPrice: {
    color: 'white',
    fontWeight: 'bold',
    fontSize: 12,
  },
  markerArrow: {
    width: 0,
    height: 0,
    backgroundColor: 'transparent',
    borderStyle: 'solid',
    borderLeftWidth: 6,
    borderRightWidth: 6,
    borderTopWidth: 8,
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent',
    borderTopColor: '#0066cc',
    transform: [{ rotate: '180deg' }],
  },
});

export default PropertyListingScreen;
